---
title: "Default WGCNA"
output: html_notebook
---

# **Default *limma* & WGCNA Pipeline**

This is a computational pipeline for the paper:

The objective of this analysis is to demonstrate the default pipeline in determining differentially expressed genes using limma package and associate biological pathways using WGCNA. Specifically,

1.  To identify the differentially expressed genes between healthy vs diseased (septic) patients, nonshock vs shock patients
2.  To associate significant pathways involved in the disease processes

# 1. Preview of the raw dataset

The [dataset](https://drive.google.com/drive/folders/1_ZokxEL1OfpQuu7nZlSobOy05OSzRpER?usp=drive_link) include the following:

1.  *annotated data* - characteristics or details of the genes/probes used in the microrray chip
2.  *clinical data* - clinical parameters of each sample/patient
3.  *gene expression data* - the relative gene expression/intensity of each probe per sample/patient.

```{r}
# Activate R environment
# renv::activate()
```

```{r}
annot.df = read.csv2("dataset/sepsisAffyIllumAnnot.csv", header=T, sep = ",")
head(annot.df)
```

```{r, warning=FALSE}
clin.df = read.csv2("dataset/sepsisAffyIllumClinData.csv", header=T, sep = ",")
head(clin.df)
```

```{r,warning=FALSE}
genex.df = read.csv2("dataset/sepsisAffyIllumGenex.csv", header=T, sep = ",")
head(genex.df)
```

# 2. Data pre-processing of clinical dataset

```{r, warning=FALSE}
library(dplyr)

# Merge Age and AgeSep into a single column
clin.df$Age <- coalesce(clin.df$Age, clin.df$AgeSep)
clin.df$AgeSep <- NULL

# Coalesce the Sex, SEX, and SexSep
clin.df$Sex <- coalesce(clin.df$Sex, clin.df$SEX, clin.df$SexSep)
clin.df$SEX <- NULL
clin.df$SexSep <- NULL

# Convert NA in duration.of.illness = 1 (1 day)
clin.df$DURATION.OF.ILLNESS[is.na(clin.df$DURATION.OF.ILLNESS)] <- 1

# Convert all NA to 0
clin.df[is.na(clin.df)] = 0

clin.df
```

Here, we want to annotate the classification of each patient based on [Sepsis 3](https://jamanetwork.com/journals/jama/fullarticle/2492881) definition.

1.  `Sepsis`: 'Organ dysfunction can be identified as an acute change in total SOFA score ≥2 points consequent to the infection'
2.  `Shock`: 'A subset of sepsis where in there is with persisting hypotension requiring vasopressors to maintain MAP ≥65 mm Hg and having a serum lactate level \>2 mmol/L (18 mg/dL) despite adequate volume resuscitation'

We now apply this definition to our current dataset. Thus, we have the following variables:

1.  `Shock`: infection (`Affliction` \>0) with organ failure (`SOFA.TOTAL` \> 2) with `HYPOTENSION` \> 0
2.  `Sepsis`: infection (`Affliction` \> 0) with organ failure (`SOFA.TOTAL` \> 2)
3.  `Healthy` : no infection (`Affliction` = 0)

```{r}

clin.df <- clin.df %>%
  mutate(
    NonsepsisVsSepsis = ifelse(Affliction == 0, 0, ifelse(Affliction > 0 | SOFA.TOTAL >0, 1, NA)),
    NonshockVsShock = ifelse(Affliction == 0, NA,ifelse( (Affliction > 0 | SOFA.TOTAL >=2) & HYPOTENSION > 0,1,0))
  )

clin.df$NonsepsisVsSepsis = factor(clin.df$NonsepsisVsSepsis,
                             levels = c(0, 1),
                             labels = c("Nonsepsis", "Sepsis"))
clin.df$NonshockVsShock = factor(clin.df$NonshockVsShock,
                             levels = c(0, 1),
                             labels = c("Nonshock", "Shock"))

clin.df
```

```{r}
# renv::install('demoGraphic')
library(demoGraphic)
```

```{r}
clin.dep.vars = 'NonsepsisVsSepsis'
clin.ind.vars = c('Age', 'Sex', 'DEATH','Affliction','DURATION.OF.ILLNESS', 'SOFA.TOTAL')
clin.ind.df = clin.df[,c(clin.dep.vars, clin.ind.vars)]

# Categorical variables to factors
clin.ind.df$Sex <- factor(clin.ind.df$Sex, levels = c(1,2), labels = c("Male","Female"))
clin.ind.df$DEATH <- factor(clin.ind.df$DEATH, levels = c(0,1), labels = c("Alive","Dead"))
clin.ind.df

df1 <- clin.ind.df %>%
  filter(!is.na(NonsepsisVsSepsis))

dem.tab = demo_table(clin.ind.vars,"NonsepsisVsSepsis", df1)
dem.tab$demo_table
```

```{r}
# Between septic & shock

clin.dep.vars = 'NonshockVsShock'
clin.ind.vars = c('Age', 'Sex', 'DEATH','Affliction','DURATION.OF.ILLNESS', 'SOFA.TOTAL')
clin.ind.df2 = clin.df[,c(clin.dep.vars, clin.ind.vars)]

# Categorical variables to factors
clin.ind.df2$Sex <- factor(clin.ind.df2$Sex, levels = c(1,2), labels = c("Male","Female"))
clin.ind.df2$DEATH <- factor(clin.ind.df2$DEATH, levels = c(0,1), labels = c("Alive","Dead"))
clin.ind.df2

df2 <- clin.ind.df2 %>%
  filter(!is.na(NonshockVsShock))

dem.tab2 = demo_table(clin.ind.vars,"NonshockVsShock", df2)
dem.tab2$demo_table

```

```{r}
# Save to csv
write.csv(clin.df,'dataset/preprocessed_clindf_Annot.csv')
```

# 3. Data pre-processing of microarray dataset

```{r, warning=FALSE}
# BiocManager::install(c("GO.db", "preprocessCore", "impute") )
# BiocManager::install("WGCNA")

library(WGCNA)
```

```{r}
genex.df.collapsed = (collapseRows(genex.df %>% select(-"TargetID"), genex.df$TargetID, rowID = row.names(genex.df)))
```

```{r}
removed.rows = genex.df$TargetID[!genex.df.collapsed$selectedRow]
genex.df.removed = genex.df %>% filter(TargetID %in% removed.rows)
head(genex.df.removed,10)
```

# 4. Parametrizing gene expression using log transform

```{r}
#renv::install('tibble')
library(tibble)
library(Biobase)
library(annotate)

df <- df 
phenData = AnnotatedDataFrame(clin.df %>% column_to_rownames(var = "PatientID"))
```

```{r}
genex.df.collapsed.matrix = genex.df.collapsed$datETcollapsed
genex.df.collapsed.matrix.log = log2(genex.df.collapsed.matrix)
genex.df.collapsed.matrix.log[is.nan(genex.df.collapsed.matrix.log)] <- 0
hist(genex.df.collapsed.matrix.log,
     xlab = 'Collapsed Matrix',
     main = 'Histogram With Log2 Transform')
```

```{r}
selected.probes = genex.df$TargetID[genex.df.collapsed$selectedRow]
annot.df.collapsed = annot.df %>% filter(GeneSymbol %in% selected.probes)
annot.df.collapsed.sorted <- annot.df.collapsed[
                                match(row.names(genex.df.collapsed.matrix.log),
                                     annot.df.collapsed$GeneSymbol), ]
row.names(annot.df.collapsed.sorted) = NULL
featData = AnnotatedDataFrame(annot.df.collapsed.sorted %>%
                                column_to_rownames(var="GeneSymbol"))
```

```{r}
eSet = new("ExpressionSet",
           exprs= as.matrix(genex.df.collapsed.matrix.log),
           phenoData = phenData,
           featureData = featData)
eSet
```

```{r}
summary(exprs(eSet))[,1:5]
```

# 5. Normalizing gene expression using the *limma* package

```{r, warning=FALSE}
#renv::install('limma')
library(limma)

normData = normalizeBetweenArrays(exprs(eSet))
eSet.norm = new("ExpressionSet",
           exprs= as.matrix(normData),
           phenoData = phenData,
           featureData = featData)
boxplot(exprs(eSet.norm)[,1:10])
```

```{r}
summary(exprs(eSet.norm))[,1:5]
```

# 6. Removing batch effects

```{r, warning=FALSE}
# renv::install('sva')
# renv::install('pamr')
library(sva)
library(pamr)
```

```{r}
phenData = pData(eSet.norm)
batch = phenData$Batch

## Modeling
## original variable of interest
mod = model.matrix(~as.factor(Affliction), data=phenData)

## intercept, no covariates
mod0 = model.matrix(~1, data=phenData)

## intercept, no covariates
modcombat = model.matrix(~1, data=phenData)
```

```{r}
combat.data = ComBat(dat=exprs(eSet.norm),
                      batch = batch,
                      mod = modcombat,
                      par.prior = TRUE,
                      prior.plots = FALSE)
head(combat.data)[,1:5]
```

```{r}
eSet.norm.combat = eSet.norm
exprs(eSet.norm.combat) = combat.data
eSet.norm.combat
```

```{r}
summary(exprs(eSet.norm.combat))[,1:5]
```

# 7. Removing bad samples and genes

```{r, warning=FALSE}
dat.matrix = exprs(eSet.norm.combat)
dat.expr = as.data.frame(t(dat.matrix))
head(dat.expr)
```

```{r}
gsg = goodSamplesGenes(dat.expr, verbose = 3)

if(sum(!gsg$goodSamples)>0) {
  summary(exprs(eSet.norm.combat))[,!gsg$goodSamples]
}
sprintf("There are %d bad samples in the dataset.", sum(!gsg$goodSamples))

if(sum(!gsg$goodGenes)) {
  bad.genes.list = colnames(dat.expr)[!gsg$goodGenes]
}
sprintf('There are %d bad genes in the dataset.', sum(!gsg$goodGenes))
```

```{r}
dat.expr = dat.expr[gsg$goodSamples, gsg$goodGenes]
head(dat.expr)
```

```{r}
sampleTree = hclust(dist(dat.expr), method = "average")
plot(sampleTree, 
     main = "Tree cluster for outlier detection", sub="", xlab="", 
     cex.lab = 1.5, cex.axis = 1.5, cex.main = 2,
     )
h=25
clust = cutreeStatic(sampleTree, cutHeight = h, minSize = 10)
table(clust)
```

# 8. Linking good samples to their clinical profile

```{r}
# We are only interested in the clinical features (i.e. Remove batch)
traits.df = clin.df[,-c(4)] 
head(traits.df)
```

```{r}
# Again, consider cluster 1 only
dat.expr.clustered = dat.expr[(clust==1),]
traitRows = match(rownames(dat.expr.clustered), traits.df$PatientID)

traits.df.clustered = traits.df[traitRows, ] %>%
                        as_tibble() %>%
                        column_to_rownames(var="PatientID")
# There may be NaNs inside so make sure the values inside the dataframe are consistent, and they do make sense to you.
traits.df.clustered = traits.df.clustered %>%
                          mutate(
                            Affliction = as.numeric(Affliction),
                            NonsepsisVsSepsis = as.numeric(NonsepsisVsSepsis),
                            NonshockVsShock = as.numeric(NonshockVsShock)
                            
                          )
str(traits.df.clustered)
```

```{r}
sampleTree.clustered = hclust(dist(dat.expr.clustered), method = "average")
plot(sampleTree.clustered, main = "Final clustered dataset", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)

# Convert traits to a color representation:
# white means low, red means high, grey means missing entry

traitColors = numbers2colors(traits.df.clustered, signed = FALSE);

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree.clustered, traitColors,
                    groupLabels = names(traits.df.clustered), 
                    main = "Dendrogram and trait heatmap of samples")

```

# 9. Sorting gene expression data based on SEPSIS 3

We now have identified the `goodSamples` and `goodGenes` in `dat.expr.clustered` and `traits.df.clustered`. We want to save separetely the gene expression datasets based on the following outcomes:

1.  `genex_nonsepsis.txt`
2.  `genex_sepsis.csv`
3.  `genex_nonshock.csv`
4.  `genex_shock.csv`

```{r}
# Let's invert the matrix so that patientID are the columns
dat.expr.clustered.tr = as.data.frame(t(dat.expr.clustered))
dat.expr.clustered.tr <- dat.expr.clustered.tr %>%
  rownames_to_column(var = "Genes") 

## NonsepsisVsSepsis
nonsepsis.vs.sepsis.clustered.df = traits.df.clustered %>% 
  filter(!is.na(NonsepsisVsSepsis)) %>% 
  dplyr::select(-NonshockVsShock) %>%
  mutate(NonsepsisVsSepsis = ifelse(NonsepsisVsSepsis == 1, 0, 
                                    ifelse(NonsepsisVsSepsis == 2, 1, NonsepsisVsSepsis)))
  
nonsepsis.pt = nonsepsis.vs.sepsis.clustered.df %>% 
  filter(NonsepsisVsSepsis==0) %>% rownames(.)
dat.expr.clustered.tr[,c("Genes",nonsepsis.pt)] %>% 
  write.table(file = "genex2_nonsepsis.txt", sep = "\t", 
              quote = FALSE, row.names = FALSE, col.names = TRUE)


sepsis.pt = nonsepsis.vs.sepsis.clustered.df %>% 
  filter(NonsepsisVsSepsis==1) %>% rownames(.)
dat.expr.clustered.tr[,c("Genes",sepsis.pt)] %>% 
  write.table(file = "genex2_sepsis.txt", sep = "\t", 
              quote = FALSE, row.names = FALSE, col.names = TRUE)

## NonshockVsShock    
nonshock.vs.shock.clustered.df = traits.df.clustered %>% 
  filter(!is.na(NonshockVsShock)) %>%
  dplyr::select(-NonsepsisVsSepsis) %>%
  mutate(NonshockVsShock = ifelse(NonshockVsShock == 1, 0, 
                                    ifelse(NonshockVsShock == 2, 1, NonshockVsShock)))

nonshock.pt = nonshock.vs.shock.clustered.df %>% 
  filter(NonshockVsShock==0) %>% rownames(.)
dat.expr.clustered.tr[,c("Genes", nonshock.pt)] %>% 
  write.table(file = "genex2_preshock.txt", sep = "\t", 
              quote = FALSE, row.names = FALSE, col.names = TRUE)

shock.pt = nonshock.vs.shock.clustered.df %>% 
  filter(NonshockVsShock==1) %>% rownames(.)
dat.expr.clustered.tr[,c("Genes", shock.pt)] %>% 
  write.table(file = "genex2_shock.txt", sep = "\t", 
              quote = FALSE, row.names = FALSE, col.names = TRUE)
```

## 9.1 Coefficient of Variation (Diseased vs Healthy)

```{r}
compute_cv <- function(expression_matrix) {
  apply(expression_matrix, 1, function(x) sd(x) / mean(x))  # Compute CV for each gene
}
```

```{r}
# Compute CV for each gene in both groups
cv_healthy <- compute_cv(genex.df.collapsed.matrix[,c(nonsepsis.pt)])
cv_diseased <- compute_cv(genex.df.collapsed.matrix[,c(sepsis.pt)])
# Combine into a data frame for visualization
cv_df <- data.frame(
  Gene = rownames(genex.df.collapsed.matrix),
  CV_Healthy = cv_healthy,
  CV_Diseased = cv_diseased
)

# Reshape data for ggplot2
cv_melted <- reshape2::melt(cv_df, id.vars = "Gene", variable.name = "Condition", value.name = "CV")

# Boxplot comparing CV distributions
ggplot(cv_melted, aes(x = Condition, y = CV, fill = Condition)) +
  geom_boxplot(alpha = 0.7) +
  theme_minimal() +
  ggtitle("Coefficient of Variation (CV) in Gene Expression") +
  ylab("Coefficient of Variation (CV)") +
  xlab("Condition") +
  scale_fill_manual(values = c("blue", "red")) 

# Perform a paired t-test
t_test_result <- t.test(cv_df$CV_Healthy, cv_df$CV_Diseased, paired = TRUE)
print(t_test_result)
```

```{r}
# Compute CV for each gene in both groups
cv_nonshock <- compute_cv(genex.df.collapsed.matrix[,c(nonshock.pt)])
cv_shock <- compute_cv(genex.df.collapsed.matrix[,c(shock.pt)])
# Combine into a data frame for visualization
cv_df <- data.frame(
  Gene = rownames(genex.df.collapsed.matrix),
  CV_Nonshock = cv_nonshock,
  CV_Shock = cv_shock
)

# Reshape data for ggplot2
cv_melted <- reshape2::melt(cv_df, id.vars = "Gene", variable.name = "Condition", value.name = "CV")

# Boxplot comparing CV distributions
ggplot(cv_melted, aes(x = Condition, y = CV, fill = Condition)) +
  geom_boxplot(alpha = 0.7) +
  theme_minimal() +
  ggtitle("Coefficient of Variation (CV) in Gene Expression") +
  ylab("Coefficient of Variation (CV)") +
  xlab("Condition") +
  scale_fill_manual(values = c("blue", "red")) 
t_test_result <- t.test(cv_df$CV_Nonshock, cv_df$CV_Shock, paired = TRUE)
print(t_test_result)
```

## 9.2 PCA

```{r}

library(ggplot2)
library(ggforce)  # For stat_ellipse()
library(dplyr)
library(sf)  # For spatial operations

# Simulated example: Assume you already have gene expression matrices
# healthy_data: NxM matrix (N genes, M healthy samples)
# diseased_data: NxK matrix (N genes, K diseased samples)

# Combine both datasets
healthy_data = dat.expr.clustered.tr[,c(nonsepsis.pt)]
diseased_data = dat.expr.clustered.tr[,c(sepsis.pt)]
combined_data <- cbind(healthy_data, diseased_data)

# Transpose the matrix so that PCA runs on samples (columns become rows)
pca_result <- prcomp(t(combined_data), scale. = TRUE)


# Create PCA DataFrame
pca_df <- data.frame(PC1 = pca_result$x[,1], 
                     PC2 = pca_result$x[,2], 
                     Condition = rep(c("Healthy", "Diseased"), c(ncol(healthy_data), ncol(diseased_data))))

# Function to generate closed ellipse points
ellipse_points <- function(df, level = 0.95, n = 100) {
  cov_mat <- cov(df[, c("PC1", "PC2")])
  mean_vals <- colMeans(df[, c("PC1", "PC2")])
  
  angles <- seq(0, 2 * pi, length.out = n)
  ellipse_coords <- t(chol(cov_mat)) %*% rbind(cos(angles), sin(angles))
  
  coords <- data.frame(
    PC1 = mean_vals[1] + ellipse_coords[1,],
    PC2 = mean_vals[2] + ellipse_coords[2,]
  )
  
  # Close the polygon by adding the first point at the end
  coords <- rbind(coords, coords[1,])
  return(coords)
}

# Generate closed ellipses
ellipse_healthy <- ellipse_points(pca_df %>% filter(Condition == "Healthy"))
ellipse_diseased <- ellipse_points(pca_df %>% filter(Condition == "Diseased"))

# Convert to sf polygons
poly_healthy <- st_polygon(list(as.matrix(ellipse_healthy)))
poly_diseased <- st_polygon(list(as.matrix(ellipse_diseased)))

# Compute overlap
intersect_area <- st_area(st_intersection(st_sfc(poly_healthy, crs = 4326), 
                                          st_sfc(poly_diseased, crs = 4326)))
total_area <- min(st_area(st_sfc(poly_healthy, crs = 4326)), 
                  st_area(st_sfc(poly_diseased, crs = 4326)))

overlap_value <- if (!is.na(intersect_area)) { 
  (intersect_area / total_area) * 100 
} else { 0 }
```

```{r}
# PCA Plot
p = ggplot(pca_df, aes(x = PC1, y = PC2, color = Condition, fill = Condition)) +
  geom_point(size = 3, alpha = 0.8) +  # Scatter points
  stat_ellipse(geom = "polygon", alpha = 0.2, linetype = "solid") +  # Ellipse with transparency
  labs(title = "", x = "PC1", y = "PC2") +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove gridlines
    axis.line = element_line(color = "black"),  # Add axis lines
    axis.title = element_text(size = 14, face = "bold"),  # Increase font size of axis labels
    axis.text = element_text(size = 12),  # Increase tick label size  # Make tick marks thicker
  ) 

# Extract axis limits
plot_limits <- ggplot_build(p)$layout$panel_params[[1]]
xmin <- plot_limits$x.range[1]
ymin <- plot_limits$y.range[1]

png("PCA_DiseasedVsHealthy.png",width=7,height=5,units="in",res=600)
# Add annotation at lower-left
p + annotate("text", x = xmin + 0.05 * (plot_limits$x.range[2] - xmin),  
             y = ymin + 0.05 * (plot_limits$y.range[2] - ymin), 
             label = sprintf("Overlap = %.2f%%", overlap_value), 
             size = 5, hjust = 0, vjust = 0, color = "black")
```

```{r}
# Load necessary library
library(ggplot2)

# Simulated example: Assume you already have gene expression matrices
# healthy_data: NxM matrix (N genes, M healthy samples)
# diseased_data: NxK matrix (N genes, K diseased samples)

# Combine both datasets
nonshock_data = dat.expr.clustered.tr[,c(nonshock.pt)]
shock_data = dat.expr.clustered.tr[,c(shock.pt)]
combined_data <- cbind(nonshock_data, shock_data)

# Transpose the matrix so that PCA runs on samples (columns become rows)
pca_result <- prcomp(t(combined_data), scale. = TRUE)

# Create a dataframe for plotting
pca_df <- data.frame(PC1 = pca_result$x[,1], 
                     PC2 = pca_result$x[,2], 
                     Condition = rep(c("Nonshock", "Shock"), c(ncol(nonshock_data), ncol(shock_data))))

# Function to generate closed ellipse points
ellipse_points <- function(df, level = 0.95, n = 100) {
  cov_mat <- cov(df[, c("PC1", "PC2")])
  mean_vals <- colMeans(df[, c("PC1", "PC2")])
  
  angles <- seq(0, 2 * pi, length.out = n)
  ellipse_coords <- t(chol(cov_mat)) %*% rbind(cos(angles), sin(angles))
  
  coords <- data.frame(
    PC1 = mean_vals[1] + ellipse_coords[1,],
    PC2 = mean_vals[2] + ellipse_coords[2,]
  )
  
  # Close the polygon by adding the first point at the end
  coords <- rbind(coords, coords[1,])
  return(coords)
}

# Generate closed ellipses
ellipse_healthy <- ellipse_points(pca_df %>% filter(Condition == "Nonshock"))
ellipse_diseased <- ellipse_points(pca_df %>% filter(Condition == "Shock"))

# Convert to sf polygons
poly_healthy <- st_polygon(list(as.matrix(ellipse_healthy)))
poly_diseased <- st_polygon(list(as.matrix(ellipse_diseased)))

# Compute overlap
intersect_area <- st_area(st_intersection(st_sfc(poly_healthy, crs = 4326), 
                                          st_sfc(poly_diseased, crs = 4326)))
total_area <- min(st_area(st_sfc(poly_healthy, crs = 4326)), 
                  st_area(st_sfc(poly_diseased, crs = 4326)))

overlap_value <- if (!is.na(intersect_area)) { 
  (intersect_area / total_area) * 100 
} else { 0 }


# PCA Plot
p = ggplot(pca_df, aes(x = PC1, y = PC2, color = Condition, fill = Condition)) +
  geom_point(size = 3, alpha = 0.8) +  # Scatter points
  stat_ellipse(geom = "polygon", alpha = 0.2, linetype = "solid") +  # Ellipse with transparency
  labs(title = "", x = "PC1", y = "PC2") +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove gridlines
    axis.line = element_line(color = "black"),  # Add axis lines
    axis.title = element_text(size = 14, face = "bold"),  # Increase font size of axis labels
    axis.text = element_text(size = 12),  # Increase tick label size  # Make tick marks thicker
  ) 

# Extract axis limits
plot_limits <- ggplot_build(p)$layout$panel_params[[1]]
xmin <- plot_limits$x.range[1]
ymax <- plot_limits$y.range[2]

# Add annotation at upper-left
png("PCA_ShockVsNonshock.png",width=7,height=5,units="in",res=600)
p + annotate("text", x = xmin + 0.05 * (plot_limits$x.range[2] - xmin),  
             y = ymax - 0.05 * (ymax - plot_limits$y.range[1]), 
             label = sprintf("Overlap = %.2f%%", overlap_value), 
             size = 5, hjust = 0, vjust = 1, color = "black")

```

# 10. Identifying differentially-expressed genes (DEGs)

```{r}
annot.df.collapsed.sorted.goodGenes = annot.df.collapsed.sorted[gsg$goodGenes,]
annot.df.collapsed.sorted.goodGenes = annot.df.collapsed.sorted.goodGenes %>%
                        column_to_rownames(var = "GeneSymbol")
dim(annot.df.collapsed.sorted.goodGenes)
```

```{r}
dim(dat.expr.clustered)
dim(traits.df.clustered)
```

## 10.1 Sepsis Vs Nonsepsis

```{r}
nonsepsis.vs.sepsis.pts = rownames(nonsepsis.vs.sepsis.clustered.df)

matrix.final = exprs(eSet.norm)[, nonsepsis.vs.sepsis.pts, drop = FALSE]
pdata.final = AnnotatedDataFrame(
  traits.df.clustered[nonsepsis.vs.sepsis.pts,!colnames(traits.df.clustered) %in% 'NonshockVsShock' ,drop = FALSE]
)
fdata.final = AnnotatedDataFrame(annot.df.collapsed.sorted.goodGenes)
eSet.final = new("ExpressionSet", 
                exprs = matrix.final,
                phenoData = pdata.final,
                featureData = fdata.final
                )
eSet.final
```

```{r}
# make proper column names to match toptable 
fvarLabels(eSet.final) <- make.names(fvarLabels(eSet.final))
eSet.final
```

```{r}
disease_status = factor(ifelse(eSet.final$NonsepsisVsSepsis == 1, "Nonsepsis", "Sepsis"))
disease_status = relevel(disease_status, ref = "Nonsepsis")
```

```{r}
design <- model.matrix(~ disease_status + 0, eSet.final)
colnames(design) <- levels(disease_status)
head(design)
```

```{r}
eSet.final <- eSet.final[complete.cases(exprs(eSet.final)), ] # skip missing values
fit <- lmFit(eSet.final, design)  # fit linear model
fit
```

```{r}
# Compute for the contrast: Diseased-Healthy
cts = c(paste(levels(disease_status)[2],"-",levels(disease_status)[1],sep=""))
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit.fc <- contrasts.fit(fit, cont.matrix)
fit.fc
```

```{r}
fit.fc.bayes = eBayes(fit.fc, )
degs.raw = topTable(fit.fc.bayes, adjust="fdr", sort.by="B", number=Inf) # All genes
degs.raw = subset(degs.raw, select=c("adj.P.Val","P.Value","t","B","logFC",
                                                 "Description", "GO.Biological.Process.Term",
                                                 "GO.Molecular.Function.Term","Pathway.Name",
                                                 "Protein.Domains.Description"))
degs.raw
```

```{r}
pval = 0.05
ndegs = length(degs.raw[degs.raw$adj.P.Val<pval,"adj.P.Val"])
sprintf("There are %d DEGs identified from the dataset with adjusted p-value<%0.2f.", ndegs, pval)
write.csv(degs.raw, "degs-raw-SepsisVsNonsepsis.csv", row.names = TRUE)
```

```{r}
library(ggrepel)
library(ggplot2)
top_genes <- degs.raw %>%
  arrange(desc(abs(B))) %>%
  head(20)

# Create the volcano plot
ggplot(degs.raw, aes(x = logFC, y = -log10(adj.P.Val))) +
  # Plot points: grey for p > 0.05, other colors based on conditions
  geom_point(aes(color = ifelse(adj.P.Val < 0.05 & logFC > 0, "red", 
                        ifelse(adj.P.Val < 0.05 & logFC < 0, "blue", "grey"))), 
             size = 1,show.legend = FALSE) +
  
  # # Horizontal line for p-value = 0.05 (log(p-value) = -log(0.05))
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  # 
  # # Vertical lines for logFC = ± 0.01
  geom_vline(xintercept = c(0.1, -0.1), linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "solid", color = "grey30") +
  # 
  # # Add annotations for top 10 genes based on B-statistics (you may change this to your sorting criterion)
  geom_text_repel(data = top_genes,
            aes(label = row.names(top_genes)), 
            vjust =-1, color = "black", size=3) +
  # Titles and labels
  ggtitle("Sepsis Vs Nonsepsis") +
  xlab(expression(log[2]~"FC")) +
  ylab(expression(log[10]~"p-value")) +
  theme(legend.position = "none") +
  # Adjust x-axis limits for symmetry
  xlim(c(-max(abs(degs.raw$logFC)), max(abs(degs.raw$logFC)))) +
  # Set color scale
  scale_color_manual(values = c("red" = "red", "blue" = "blue", "grey" = "grey")) +
  theme_minimal() +
  theme(panel.grid = element_blank(),  # Remove all gridlines
        axis.line = element_line(color = "black"),  # Keep the axis lines
        axis.text = element_text(size = 12, color="grey30"),  # Optional: adjust text size
        axis.title = element_text(size = 15))  # Optional: adjust axis title size
ggsave("SepsisVsNonSepsis-Degs20.png", dpi = 300, width = 6, height = 5, bg = "white")
```

## 10.2 Shock Vs Nonshock

```{r}
nonshock.vs.shock.pts = rownames(nonshock.vs.shock.clustered.df)

matrix.final.2 = exprs(eSet.norm)[, nonshock.vs.shock.pts, drop = FALSE]
pdata.final.2 = AnnotatedDataFrame(
  traits.df.clustered[nonshock.vs.shock.pts,!colnames(traits.df.clustered) %in% 'NonsepsisVsSepsis' ,drop = FALSE]
)
fdata.final = AnnotatedDataFrame(annot.df.collapsed.sorted.goodGenes)
eSet.final.2 = new("ExpressionSet", 
                exprs = matrix.final.2,
                phenoData = pdata.final.2,
                featureData = fdata.final
                )
# make proper column names to match toptable 
fvarLabels(eSet.final.2) <- make.names(fvarLabels(eSet.final.2))
eSet.final.2
```

```{r}
disease_status2 = factor(ifelse(eSet.final.2$NonshockVsShock == 1, "Sepsis", "Shock"))
disease_status2 = relevel(disease_status2, ref = "Sepsis")
disease_status2

design2 <- model.matrix(~disease_status2 +0, eSet.final.2)
colnames(design2) <- levels(disease_status2)

eSet.final.2 <- eSet.final.2[complete.cases(exprs(eSet.final.2)), ] # skip missing values
fit.2 <- lmFit(eSet.final.2, design2)  # fit linear model
fit.2

# Diseased-Healthy
cts2 = c(paste(levels(disease_status2)[2],"-",levels(disease_status2)[1],sep=""))
cont.matrix2 <- makeContrasts(contrasts=cts2, levels=design2)
fit.fc.2 <- contrasts.fit(fit.2, cont.matrix2)
fit.fc.2

fit.fc.bayes.2 = eBayes(fit.fc.2, )
degs.raw.shock = topTable(fit.fc.bayes.2, adjust="fdr", sort.by="B", number=Inf) # All genes
degs.raw.shock = subset(degs.raw.shock, select=c("adj.P.Val","P.Value","t","B","logFC",
                                                 "Description", "GO.Biological.Process.Term",
                                                 "GO.Molecular.Function.Term","Pathway.Name",
                                                 "Protein.Domains.Description"))
degs.raw.shock
```

```{r}
pval = 0.05
ndegs.2 = length(degs.raw.shock[degs.raw.shock$adj.P.Val<pval,"adj.P.Val"])
sprintf("There are %d DEGs (shock) identified from the dataset with adjusted p-value<%0.2f.", ndegs.2, pval)
write.csv(degs.raw.shock, "degs-raw-ShockVsNonshock.csv", row.names = TRUE)
```

```{r}
library(ggplot2)
library(ggrepel)

top_genes <- degs.raw.shock %>%
  arrange(desc(abs(B))) %>%
  head(20)

# Create the volcano plot
ggplot(degs.raw.shock, aes(x = logFC, y = -log10(adj.P.Val))) +
  # Plot points: grey for p > 0.05, other colors based on conditions
  geom_point(aes(color = ifelse(adj.P.Val < 0.05 & logFC > 0, "red", 
                        ifelse(adj.P.Val < 0.05 & logFC < 0, "blue", "grey"))), 
             size = 1,show.legend = FALSE) +
  
  # # Horizontal line for p-value = 0.05 (log(p-value) = -log(0.05))
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  # 
  # # Vertical lines for logFC = ± 0.01
  geom_vline(xintercept = c(0.05, -0.05), linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "solid", color = "grey30") +
  # 
  # # Add annotations for top 10 genes based on B-statistics (you may change this to your sorting criterion)
  # geom_text_repel(data = top_genes,
  #           aes(label = row.names(top_genes)), 
  #           vjust =-1, color = "black", size=3) +
  # Titles and labels
  ggtitle("Shock Vs Nonshock") +
  xlab(expression(log[2]~"FC")) +
  ylab(expression(log[10]~"p-value")) +
  theme(legend.position = "none") +
  # Adjust x-axis limits for symmetry
  xlim(c(-max(abs(degs.raw.shock$logFC)), max(abs(degs.raw.shock$logFC)))) +
  # Set color scale
  scale_color_manual(values = c("red" = "red", "blue" = "blue", "grey" = "grey")) +
  theme_minimal() +
  theme(plot.margin = margin(0, 0.5, 0, 0, "cm")) +
  theme(panel.grid = element_blank(),  # Remove all gridlines
        axis.line = element_line(color = "black"),  # Keep the axis lines
        axis.text = element_text(size = 12, color="grey30"),  # Optional: adjust text size
        axis.title = element_text(size = 15))  # Optional: adjust axis title size
ggsave("ShockVsNonshock-Degs20.png", dpi = 300, width = 6, height = 5, bg = "white")
```

# 11. Detecting correlated modules and eigengenes

```{r}
library(WGCNA)
options(stringsAsFactors = FALSE)
disableWGCNAThreads()
```

## 11.1 Sepsis vs Nonsepsis

```{r}
ggset = as.data.frame(t(exprs(eSet.final)))
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(ggset, powerVector = powers, verbose = 5, RsquaredCut = 0.90)
sft$powerEstimate
```

```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",
     type="n",
     main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
      xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
      main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")


```

```{r}
softPower = sft$powerEstimate;
adj = adjacency(ggset, power = softPower)
dim(adj)
```

```{r}
TOM = TOMsimilarity(adj);
dissTOM = 1-TOM
dim(TOM)
```

```{r}
# Call the hierarchical clustering function
geneTree = hclust(as.dist(dissTOM), method = "average");
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", 
     main = "Gene clustering of SepsisVsNonSepsis based on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
```

```{r}
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;

# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize)
table(dynamicMods)

```

```{r}
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram of Sepsis Vs Nonsepsis")

```

```{r}
# Calculate eigengenes
MEList = moduleEigengenes(ggset, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(16, 8)
plot(METree, main = "Clustering of module eigengenes in Sepsis vs Nonsepsis",
xlab = "", sub = "")
# Merging modules
MEDissThres = 0.40
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
```

```{r}
# Call an automatic merging function
merge = mergeCloseModules(ggset, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
```

```{r}
sizeGrWindow(12, 9)
#pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
png("Dendogram_HealthyVsDiseased.png",width=7,height=5,units="in",res=600)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
main = "Gene dendrogram of Sepsis Vs Nonsepsis"
#dev.off()

```

```{r}
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs
dim(MEs)

# Create a dataframe
df <- data.frame(
  genes = colnames(ggset),
  modules = moduleColors
)
# Save the dataframe to a CSV file
output_file <- "moduleColors_SepsisVsHealthy.csv"
write.csv(df, file = output_file, row.names = F)
dim(df)
```

## 11.2 Shock vs Nonshock

We shall use `eSet.final.2` for `Shock vs Nonshock`.

```{r}
ggset.2 = as.data.frame(t(exprs(eSet.final.2)))
powers2 = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft.2 = pickSoftThreshold(ggset.2, powerVector = powers2, verbose = 5, RsquaredCut = 0.90)
sft.2$powerEstimate
```

```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft.2$fitIndices[,1], -sign(sft.2$fitIndices[,3])*sft.2$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",
     type="n",
     main = paste("Scale independence"))
text(sft.2$fitIndices[,1], -sign(sft.2$fitIndices[,3])*sft.2$fitIndices[,2],
     labels=powers2,cex=cex1,col="red")
plot(sft.2$fitIndices[,1], sft.2$fitIndices[,5],
      xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
      main = paste("Mean connectivity"))
text(sft.2$fitIndices[,1], sft.2$fitIndices[,5], labels=powers2, cex=cex1,col="red")
```

```{r}
softPower = sft.2$powerEstimate
adj.2 = adjacency(ggset.2, power = softPower)
dim(adj.2)
```

```{r}
TOM.2 = TOMsimilarity(adj.2);
dissTOM.2 = 1-TOM.2
dim(TOM.2)
```

```{r}
# Call the hierarchical clustering function
geneTree.2 = hclust(as.dist(dissTOM.2), method = "average");
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree.2, xlab="", sub="", 
     main = "Gene clustering of Shock vs Nonshock based on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
```

```{r}
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;

# Module identification using dynamic tree cut:
dynamicMods2 = cutreeDynamic(dendro = geneTree.2, distM = dissTOM.2,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize)
table(dynamicMods2)
```

```{r}
# Convert numeric lables into colors
dynamicColors2 = labels2colors(dynamicMods2)
table(dynamicColors2)

# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree.2, dynamicColors2, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram of Non-shock Vs Shock")
```

```{r}
# Calculate eigengenes
MEList.2 = moduleEigengenes(ggset.2, colors = dynamicColors2)
MEs.2 = MEList.2$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss.2 = 1-cor(MEs.2);
# Cluster module eigengenes
METree.2 = hclust(as.dist(MEDiss.2), method = "average");
# Plot the result
sizeGrWindow(16, 8)
plot(METree.2, main = "Clustering of module eigengenes in Shock vs Nonshock",
xlab = "", sub = "")
# Merging modules
MEDissThres = 0.40
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
```

```{r}
# Call an automatic merging function
merge2 = mergeCloseModules(ggset.2, dynamicColors2, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors2 = merge2$colors
# Eigengenes of the new merged modules:
mergedMEs2 = merge2$newMEs
```

```{r}
sizeGrWindow(12, 9)
# pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
png("Dendogram_NonshockVsShock.png",width=7,height=5,units="in",res=600)
plotDendroAndColors(geneTree.2, cbind(dynamicColors2, mergedColors2),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
main = "Gene dendogram of Non-shock Vs Shock"
#dev.off()
```

```{r}
# Rename to moduleColors
moduleColors2 = mergedColors2
# Construct numerical labels corresponding to the colors
colorOrder2 = c("grey", standardColors(50));
moduleLabels2 = match(moduleColors2, colorOrder2)-1;
MEs2 = mergedMEs2
dim(MEs2)

# Create a dataframe
df <- data.frame(
  genes = colnames(ggset.2),
  modules = moduleColors2
)
# Save the dataframe to a CSV file
output_file <- "moduleColors_ShockVsNonshock.csv"
write.csv(df, file = output_file, row.names = F)
dim(df)
```

# 12. Associating with clinical traits

For `datTraits`, note that `Nonsepsis = 1` and `Sepsis = 2` so that a `r` \> 0 implies positive correlation to `Sepsis`. Similarly, `Nonshock = 1` and `Shock = 2`.

## 12.1 Sepsis Vs Nonsepsis

```{r}
# Define numbers of genes and samples
datExpr = ggset
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
datTraits = pData(eSet.final)

```

```{r}
library(stringr)
# Step 1: Rename columns
datTraits = pData(eSet.final)
colnames(datTraits)[colnames(datTraits) == "NonsepsisVsSepsis"] <- "HealthyVsDiseased"
colnames(datTraits)[colnames(datTraits) == "SepsisAlivevsDead"] <- "AliveVsDead"
colnames(datTraits)[colnames(datTraits) == "SOFA.TOTAL"] <- "SOFA"
colnames(datTraits)[colnames(datTraits) == "SIRS.RESULT"] <- "SIRS"
colnames(datTraits)[colnames(datTraits) == "DEATH"] <- "Mortality"

datTraits <- datTraits %>%
  dplyr::select(-c(UncompVsComp, UncompVsShock, SEPSISvHealthy, SepsisvFebrile))


# Step 2: Capitalize only the first letter of each word (except for HealthyVsDiseased)
capitalize_first_letter <- function(x) {
  sapply(x, function(y) {
    if (!y %in% c("HealthyVsDiseased","AliveVsDead", "SOFA", "SIRS")) {
      y <- gsub("([[:punct:]])", " ", y)  # Replace punctuation with space
      y <- gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2", y, perl = TRUE)
      y <- str_to_title(y)
    }
    return(y)
  })
}

colnames(datTraits) <- capitalize_first_letter(colnames(datTraits))

# Step 3: Remove punctuation marks
colnames(datTraits) <- gsub("[[:punct:]]", "", colnames(datTraits))

# Step 4: Reorder
colnames(datTraits)[colnames(datTraits) == "HealthyVsDiseased"] <- "DiseasedVsHealthy"
datTraits <- datTraits %>% dplyr::select("Age", "Sex", "Mortality", "Duration Of Illness",
                                  "SIRS", "Neuro Outcome", "Pulmo Outcome", "Renal Outcome",
                                  "Liver Outcome", "SOFA", "Hypotension", "AliveVsDead",
                                  "DiseasedVsHealthy")

# Check the result
colnames(datTraits)
```

```{r}

# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
```

```{r}
library(ggplot2)

# Will display correlations and their p-values
png("WGCNAModules_NonsepsisVsSepsis.png",width=7,height=5,units="in",res=600)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
                    dim(textMatrix) = dim(moduleTraitCor)
                    par(mar = c(6, 10, 3, 3))
par(mar = c(8, 8, 2, 1))  # Reduce margins (bottom, left, top, right)
labeledHeatmap(Matrix = moduleTraitCor,
              xLabels = names(datTraits),
              yLabels = names(MEs),
              ySymbols = names(MEs),
              colorLabels = FALSE,
              colors = blueWhiteRed(50),
              textMatrix = textMatrix,
              setStdMargins = FALSE,
              cex.text = 0.3,
              zlim = c(-1,1),
              main = paste("Diseased vs Healthy"))
```

```{r}
# Gene Significance and Module Membership
# Define variable of clinical interest containing the column of datTraits
Nonsepsis.vs.Sepsis.traits = as.data.frame(datTraits$DiseasedVsHealthy);
names(Nonsepsis.vs.Sepsis.traits) = "DiseasedVsHealthy"

# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="")

geneTraitSignificance = as.data.frame(cor(datExpr, Nonsepsis.vs.Sepsis.traits, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(Nonsepsis.vs.Sepsis.traits), sep="")
names(GSPvalue) = paste("p.GS.", names(Nonsepsis.vs.Sepsis.traits), sep="")
```

```{r}
dim(annot.df.collapsed.sorted)
annot = annot.df.collapsed.sorted
probes = names(datExpr)
probes2annot = match(probes, annot$GeneSymbol)

# The following is the number or probes without annotation:
sprintf("Number of no annotations: %d.", sum(is.na(probes2annot)))
```

```{r}
# We now create a data frame holding the following information for all probes
# modules will be ordered by their significance, with the most significant ones to the left
# Create the starting data frame
geneInfo0 = data.frame(TargetID = probes,
                      # geneSymbol = annot$GeneSymbol[probes2annot],
                      # LocusLinkID = annot$ENTREZ_GENE_ID,
                      moduleColor = moduleColors,
                      geneTraitSignificance,
                      GSPvalue)

# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.DiseasedVsHealthy));
geneInfo = geneInfo0[geneOrder, ]
```

```{r}
geneInfo
write.csv(geneInfo, "geneInfo-HealthyVsDiseased.csv")
```

## 12.3 Shock vs Nonshock

```{r}
# Define numbers of genes and samples
datExpr = ggset.2
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
datTraits = pData(eSet.final.2)
```

```{r}
library(stringr)
# Step 1: Rename columns
datTraits = pData(eSet.final.2)
colnames(datTraits)[colnames(datTraits) == "SepsisAlivevsDead"] <- "AliveVsDead"
colnames(datTraits)[colnames(datTraits) == "SOFA.TOTAL"] <- "SOFA"
colnames(datTraits)[colnames(datTraits) == "SIRS.RESULT"] <- "SIRS"
colnames(datTraits)[colnames(datTraits) == "DEATH"] <- "Mortality"

datTraits <- datTraits %>%
  dplyr::select(-c(UncompVsComp, UncompVsShock, SEPSISvHealthy, SepsisvFebrile))


# Step 2: Capitalize only the first letter of each word (except for HealthyVsDiseased)
capitalize_first_letter <- function(x) {
  sapply(x, function(y) {
    if (!y %in% c("NonshockVsShock","AliveVsDead", "SOFA", "SIRS")) {
      y <- gsub("([[:punct:]])", " ", y)  # Replace punctuation with space
      y <- gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2", y, perl = TRUE)
      y <- str_to_title(y)
    }
    return(y)
  })
}

colnames(datTraits) <- capitalize_first_letter(colnames(datTraits))

# Step 3: Remove punctuation marks
colnames(datTraits) <- gsub("[[:punct:]]", "", colnames(datTraits))

# Step 4: Reorder
colnames(datTraits)[colnames(datTraits) == "NonshockVsShock"] <- "ShockVsNonshock" # Name convention of WGCNA 
datTraits <- datTraits %>% dplyr::select("Age", "Sex", "Mortality", "Duration Of Illness",
                                  "SIRS", "Neuro Outcome", "Pulmo Outcome", "Renal Outcome",
                                  "Liver Outcome", "SOFA", "Hypotension", "AliveVsDead",
                                  "ShockVsNonshock")

# Check the result
colnames(datTraits)
```

```{r}
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
```

```{r}
library(ggplot2)

# Will display correlations and their p-values
png("WGCNAModules_ShockVsNonshock.png",width=7,height=5,units="in",res=600)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
                    dim(textMatrix) = dim(moduleTraitCor)
                    par(mar = c(6, 10, 3, 3))
par(mar = c(8, 8, 2, 1))  # Reduce margins (bottom, left, top, right)
labeledHeatmap(Matrix = moduleTraitCor,
              xLabels = names(datTraits),
              yLabels = names(MEs),
              ySymbols = names(MEs),
              colorLabels = FALSE,
              colors = blueWhiteRed(50),
              textMatrix = textMatrix,
              setStdMargins = FALSE,
              cex.text = 0.3,
              zlim = c(-1,1),
              main = paste("Shock vs Nonshock"))
```

```{r}
# Gene Significance and Module Membership
# Define variable of clinical interest containing the column of datTraits
Shock.vs.Nonshock.traits = as.data.frame(datTraits$ShockVsNonshock);
names(Shock.vs.Nonshock.traits) = "ShockVsNonshock"

# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="")

geneTraitSignificance = as.data.frame(cor(datExpr, Shock.vs.Nonshock.traits, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", names(Shock.vs.Nonshock.traits), sep="")
names(GSPvalue) = paste("p.GS.", names(Shock.vs.Nonshock.traits), sep="")
```

```{r}
# We now create a data frame holding the following information for all probes
# modules will be ordered by their significance, with the most significant ones to the left
# Create the starting data frame
geneInfo1 = data.frame(TargetID = probes,
                      # geneSymbol = annot$GeneSymbol[probes2annot],
                      # LocusLinkID = annot$ENTREZ_GENE_ID,
                      moduleColor = moduleColors2,
                      geneTraitSignificance,
                      GSPvalue)

# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo1$moduleColor, -abs(geneInfo1$GS.ShockVsNonshock));
geneInfo = geneInfo1[geneOrder, ]
```

```{r}
geneInfo
write.csv(geneInfo, "geneInfo-ShockVsNonshock.csv")
```

# 13. GO Enrichment Analysis

```{r}
# renv::install("clusterProfiler")
library(clusterProfiler)
library(org.Hs.eg.db)  # Human gene annotations
library(enrichplot)     # For visualization
library(ggplot2)        # For plotting
```

## 13.1 Sepsis Vs Nonsepsis

```{r}
modules.df = read.csv("geneInfo-SepsisVsNonsepsis.csv", header=T)
modules.df
```

### A. Positively Correlated to Sepsis

```{r}
mod1 = "turquoise"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_pos_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Positive GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)


mod1 = "black"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_pos_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Positive GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)


mod1 = "yellow"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_pos_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Positive GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)

mod1 = "purple"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_pos_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Positive GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)

mod1 = "green"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_neg_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Positive GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)
```

### B. Negatively correlated to Sepsis

```{r}
mod1 = "brown"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_neg_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Negative GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
  theme(axis.text.y = element_text(size = 8),
  panel.grid.major = element_blank(),   # Remove major gridlines
  panel.grid.minor = element_blank()) +    # Remove minor gridlines +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)

mod1 = "magenta"
state = "Sepsis"
genes = modules.df[modules.df$moduleColor==mod1,]$TargetID

ego_bp <- enrichGO(
  gene         = genes, 
  OrgDb        = org.Hs.eg.db, 
  keyType      = "SYMBOL", 
  ont          = "BP",        # Choose BP (Biological Process), MF, or CC
  pAdjustMethod = "BH",       # Benjamini-Hochberg correction
  pvalueCutoff = 0.05, 
  qvalueCutoff = 0.05
)

# View top enriched GO terms
head(ego_bp)
write.csv(as.data.frame(ego_bp), paste0(mod1,"_pos_DiseasedVsHealthymodules.csv"))

# Example barplot
title = sprintf("Negative GO BP Terms for %s", state)
gplot <- barplot(ego_bp, showCategory=10, title=title, ) + 
  geom_bar(stat="identity", color="black") +
  theme(axis.text.y = element_text(size = 8),
  panel.grid.major = element_blank(),   # Remove major gridlines
  panel.grid.minor = element_blank()) +    # Remove minor gridlines +
         scale_fill_gradient(low = mod1, high = "gray90")  # Change color gradient

print(gplot)


```

## 14. DEGs Association in Sepsis (Diseased) vs Healthy

```{r}
degs.raw = read.csv("degs-raw-SepsisVsNonsepsis.csv", header=T)
head(degs.raw)
```

```{r}
library(dplyr)

# Step 1: Get Top 20 Genes from degs.raw based on abs(B) and logFC < 0
top20_genes <- degs.raw %>%
  arrange(desc(abs(B))) %>%
  slice(1:20) %>%
  filter(logFC > 0) %>%               # Keep only downregulated genes
  select(X, B, logFC, adj.P.Val)

# Step 2: Join with modules.df to get moduleColor
top20_modules <- top20_genes %>%
  left_join(modules.df, by = c("X" = "TargetID")) %>%
  select(X, moduleColor, B, logFC, adj.P.Val)

# View the result
print(top20_modules)

```

```{r}

```
